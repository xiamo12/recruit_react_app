{"ast":null,"code":"// 包含多个action creator：异步action【返回函数】和同步action【返回对象】\n// 注册的同步action里包含一个type字段和一个data字段\nimport io from 'socket.io-client';\nimport { AUTH_SUCCESS, ERROR_MSG, RECEIVE_USER, RESET_USER, RECEIVE_USER_LIST, RECEIVE_MSG_LIST, RECEIVE_MSG, MSG_READ //在action-type里定义之后，在这里引入\n} from \"./action-types\";\nimport { reqRegister, reqLogin, reqUpdateUser, reqUser, reqUserList, reqChatMsgList, reqReadMsg } from \"../api\";\n\nfunction initIO(dispatch, userid) {\n  //userid是当前用户的id\n  if (!io.socket) {\n    io.socket = io('ws://localhost:4000'); //连接服务器，得到与服务器的链接对象.创建该对象之后，保存对象\n\n    io.socket.on(\"receiveMsg\", function (chatMsg) {\n      //绑定监听，接收服务器发送的消息.服务端发过来的receiveMsg是chatMsg，因此这里接收chatMsg。io会给所有的客户端都发送消息。但我们只需要服务端给特定的客户端发送消息即可。\n      console.log('客户端接收到服务器发送的消息', chatMsg); //只有当chatMsg是与当前用户相关的消息时，才去分发同步action保存消息\n\n      if (userid === chatMsg.from || chatMsg.to === userid) {\n        dispatch(receiveMsg(chatMsg, userid));\n      }\n    }); //这段代码只需做一次就够了，因此可以把它封装成一个函数\n  }\n} //获取消息列表数据的函数\n\n\nasync function getMsgList(dispatch, userid) {\n  //此函数在用户登录成功时执行\n  initIO(dispatch, userid); //连接服务器获取消息应该在getMsgList之前做\n\n  const response = await reqChatMsgList();\n  const result = response.data;\n\n  if (result.code === 0) {\n    const _result$data = result.data,\n          users = _result$data.users,\n          chatMsgs = _result$data.chatMsgs; //分发一个同步action\n\n    dispatch(receiveMsgList({\n      users,\n      chatMsgs,\n      userid\n    }));\n  }\n} //发送消息的异步action\n\n\nexport const sendMsg = ({\n  from,\n  to,\n  content\n}) => {\n  return dispatch => {\n    //不需要async/await了\n    console.log('客户端向服务器发送消息', {\n      from,\n      to,\n      content\n    }); //通过socket发送消息\n\n    io.socket.emit(\"sendMsg\", {\n      from,\n      to,\n      content\n    }); //把消息发给服务器端\n  };\n}; //读取消息的异步action\n\nexport const readMsg = (from, to) => {\n  return async dispatch => {\n    //不需要async/await了\n    const response = await reqReadMsg(from);\n    const result = response.data;\n\n    if (result.code === 0) {\n      //去定义一个action-type\n      const count = result.data; //后台返回的\n\n      dispatch(msgRead({\n        count,\n        from,\n        to\n      }));\n    }\n  };\n}; //授权成功的同步action，返回的是一个对象\n\nconst authsuccess = user => ({\n  type: AUTH_SUCCESS,\n  data: user\n}); //无论注册成功还是登陆成功，要管理的信息都是user。\n//错误提示信息的同步action,返回的是一个对象\n\n\nconst errormsg = msg => ({\n  type: ERROR_MSG,\n  data: msg\n}); //action里必须要使用一个type字段来表示将要执行的动作，多数情况下type是字符串常量。\n//action创建函数是生成action的函数。在redux里面，可以直接将action创建函数返回的结果传入dispatch里，来发起一个dispatch过程\n//接收用户的同步action\n\n\nconst receiveUser = user => ({\n  type: RECEIVE_USER,\n  data: user\n}); //重置用户的同步action\n\n\nexport const resetUser = msg => ({\n  type: RESET_USER,\n  data: msg\n}); //接收用户列表的同步action\n\nexport const receiveUserList = userList => ({\n  type: RECEIVE_USER_LIST,\n  data: userList\n}); //接收消息列表的同步action\n\nconst receiveMsgList = ({\n  users,\n  chatMsgs,\n  userid\n}) => ({\n  type: RECEIVE_MSG_LIST,\n  data: {\n    users,\n    chatMsgs,\n    userid\n  }\n}); //接收一个消息的同步action\n\n\nconst receiveMsg = (chatMsg, userid) => ({\n  type: RECEIVE_MSG,\n  data: {\n    chatMsg,\n    userid\n  }\n}); //读取了某个聊天消息的同步action\n\n\nconst msgRead = ({\n  count,\n  from,\n  to\n}) => ({\n  type: MSG_READ,\n  data: {\n    count,\n    from,\n    to\n  }\n}); //注册的异步action.此action返回的是一个函数\n\n\nexport const register = user => {\n  const username = user.username,\n        password = user.password,\n        password2 = user.password2,\n        type = user.type; //从register组件里传递过来this.state作为user，解构出的四个参数\n\n  if (!username) {\n    return errormsg(\"用户名需指定！\");\n  } else if (password !== password2) {\n    //表单的前台验证：注册时如果两次密码不一致，返回一个errormsg的同步action。\n    return errormsg(\"2次密码要一致！\");\n  } //通过上述判断，说明表单数据合法，返回一个ajax请求的异步action函数\n\n\n  return async dispatch => {\n    //发送注册的异步ajax请求\n    const response = await reqRegister({\n      username,\n      password,\n      type\n    }); //调用api/index.js里的reqRegister请求，并传入请求参数\n\n    console.log(response); //这里的response获取到异步请求的结果，结果是一个对象，包含data、status、statusText、headers、config等属性。而data里包含我们需要的code和data数据\n\n    const result = response.data; //data数据包括code，data\n\n    if (result.code === 0) {\n      //注册成功，返回{code:0, data:{\"_id\":\"\", \"username\":\"\", \"type\": \"\"}}对象\n      getMsgList(dispatch, result.data._id); //注册成功, 调用获取消息列表的函数\n      //分发授权成功的同步action\n\n      dispatch(authsuccess(result.data)); //把action创建函数的结果直接传递给dispatch方法即可发起一次dispatch过程，调用reducer\n    } else {\n      //注册失败,返回{code:1, msg: \"\"}对象\n      dispatch(errormsg(result.msg));\n    }\n  };\n}; //登陆的异步action.此action返回的是一个函数\n\nexport const login = user => {\n  const username = user.username,\n        password = user.password;\n\n  if (!username) {\n    return errormsg(\"用户名必须指定！\");\n  } else if (!password) {\n    //表单的前台验证：注册时如果两次密码不一致，返回一个errormsg的同步action。\n    return errormsg(\"密码必须指定\");\n  }\n\n  return async dispatch => {\n    //发送注册的异步ajax请求\n    const response = await reqLogin(user);\n    const result = response.data; //data数据包括code，data\n\n    if (result.code === 0) {\n      //登陆成功\n      getMsgList(dispatch, result.data._id); //注册成功调用获取消息列表\n      //分发授权成功的同步action\n\n      dispatch(authsuccess(result.data));\n    } else {\n      //注册失败\n      dispatch(errormsg(result.msg));\n    }\n  };\n}; //更新用户状态的异步action。此action返回一个函数\n\nexport const updateUser = user => {\n  return async dispatch => {\n    const response = await reqUpdateUser(user);\n    const result = response.data;\n\n    if (result.code === 0) {\n      //更新成功 :data,分发一个同步action\n      dispatch(receiveUser(result.data));\n    } else {\n      //更新失败： msg\n      dispatch(resetUser(result.msg));\n    }\n  };\n}; //获取用户的异步action\n\nexport const getUser = () => {\n  return async dispatch => {\n    //执行异步ajax请求\n    const response = await reqUser(); //reqUser()是一个ajax请求，请求结果包括{code: xx, data:{}}\n\n    const result = response.data;\n\n    if (result.code === 0) {\n      getMsgList(dispatch, result.data._id); //注册成功调用获取消息列表\n      //成功获取数据\n\n      dispatch(receiveUser(result.data));\n    } else {\n      //获取数据失败\n      dispatch(resetUser(result.msg));\n    }\n  };\n}; //获取用户列表的异步action\n\nexport const getUserList = type => {\n  return async dispatch => {\n    //执行异步ajax请求\n    const response = await reqUserList(type); //api -> index.js -> reqUserList()，请求用户类型\n\n    const result = response.data; //得到结果之后分发一个同步action\n\n    if (result.code === 0) {\n      dispatch(receiveUserList(result.data));\n    }\n  };\n};","map":{"version":3,"sources":["/Users/luofei/recruit_react_app/recruit_react_app/src/redux/actions.js"],"names":["io","AUTH_SUCCESS","ERROR_MSG","RECEIVE_USER","RESET_USER","RECEIVE_USER_LIST","RECEIVE_MSG_LIST","RECEIVE_MSG","MSG_READ","reqRegister","reqLogin","reqUpdateUser","reqUser","reqUserList","reqChatMsgList","reqReadMsg","initIO","dispatch","userid","socket","on","chatMsg","console","log","from","to","receiveMsg","getMsgList","response","result","data","code","users","chatMsgs","receiveMsgList","sendMsg","content","emit","readMsg","count","msgRead","authsuccess","user","type","errormsg","msg","receiveUser","resetUser","receiveUserList","userList","register","username","password","password2","_id","login","updateUser","getUser","getUserList"],"mappings":"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","sourcesContent":["// 包含多个action creator：异步action【返回函数】和同步action【返回对象】\n// 注册的同步action里包含一个type字段和一个data字段\nimport io from 'socket.io-client';\nimport { \n\tAUTH_SUCCESS, \n\tERROR_MSG, \n\tRECEIVE_USER, \n\tRESET_USER, \n\tRECEIVE_USER_LIST,\n\tRECEIVE_MSG_LIST,\n\tRECEIVE_MSG,\n\tMSG_READ //在action-type里定义之后，在这里引入\n\t} from \"./action-types\";\nimport { \n\treqRegister, \n\treqLogin, \n\treqUpdateUser, \n\treqUser, \n\treqUserList,\n\treqChatMsgList,\n\treqReadMsg } from \"../api\";\n\n\nfunction initIO(dispatch, userid){ //userid是当前用户的id\n\tif (!io.socket) {\n\t\tio.socket = io('ws://localhost:4000');//连接服务器，得到与服务器的链接对象.创建该对象之后，保存对象\n\t\tio.socket.on(\"receiveMsg\", function(chatMsg){//绑定监听，接收服务器发送的消息.服务端发过来的receiveMsg是chatMsg，因此这里接收chatMsg。io会给所有的客户端都发送消息。但我们只需要服务端给特定的客户端发送消息即可。\n\t\t\tconsole.log('客户端接收到服务器发送的消息',chatMsg)\n\t\t\t//只有当chatMsg是与当前用户相关的消息时，才去分发同步action保存消息\n\t\t\tif (userid === chatMsg.from || chatMsg.to === userid) {\n\t\t\t\tdispatch(receiveMsg(chatMsg,userid))\n\t\t\t}\n\t\t}) //这段代码只需做一次就够了，因此可以把它封装成一个函数\n\t}\n}\n\n//获取消息列表数据的函数\nasync function getMsgList(dispatch, userid){ //此函数在用户登录成功时执行\n\tinitIO(dispatch, userid); //连接服务器获取消息应该在getMsgList之前做\n\tconst response = await reqChatMsgList();\n\tconst result = response.data;\n\tif (result.code === 0) {\n\t\tconst { users, chatMsgs } = result.data;\n\t\t//分发一个同步action\n\t\tdispatch(receiveMsgList({ users, chatMsgs, userid }))\n\t}\n}\n//发送消息的异步action\nexport const sendMsg = ({from, to, content}) => {\n\treturn dispatch => { //不需要async/await了\n\t\tconsole.log('客户端向服务器发送消息', {from, to, content});\n\t\t//通过socket发送消息\n\t\tio.socket.emit(\"sendMsg\",{from, to, content})//把消息发给服务器端\n\t}\n}\n//读取消息的异步action\nexport const readMsg = (from, to) => {\n\treturn async dispatch => { //不需要async/await了\n\t\tconst response = await reqReadMsg(from);\n\t\tconst result = response.data\n\t\tif (result.code === 0) {\n\t\t\t//去定义一个action-type\n\t\t\tconst count = result.data //后台返回的\n\t\t\tdispatch(msgRead({count, from, to}))\n\t\t}\n\t}\n}\n//授权成功的同步action，返回的是一个对象\nconst authsuccess = (user) => ({ type: AUTH_SUCCESS, data: user}); //无论注册成功还是登陆成功，要管理的信息都是user。\n//错误提示信息的同步action,返回的是一个对象\nconst errormsg = (msg)=> ({ type: ERROR_MSG, data: msg});//action里必须要使用一个type字段来表示将要执行的动作，多数情况下type是字符串常量。\n//action创建函数是生成action的函数。在redux里面，可以直接将action创建函数返回的结果传入dispatch里，来发起一个dispatch过程\n//接收用户的同步action\nconst receiveUser = (user)=>({type: RECEIVE_USER, data: user});\n//重置用户的同步action\nexport const resetUser = (msg)=>({type: RESET_USER, data: msg});\n//接收用户列表的同步action\nexport const receiveUserList = (userList)=>({type: RECEIVE_USER_LIST, data: userList});\n//接收消息列表的同步action\nconst receiveMsgList = ({ users, chatMsgs, userid }) => ({type: RECEIVE_MSG_LIST, data: { users, chatMsgs, userid }});\n//接收一个消息的同步action\nconst receiveMsg = (chatMsg, userid)=> ({type: RECEIVE_MSG, data: {chatMsg, userid}})\n//读取了某个聊天消息的同步action\nconst msgRead = ({count, from, to})=>({type: MSG_READ, data:{count, from, to}})\n//注册的异步action.此action返回的是一个函数\nexport const register = (user)=> { \n\tconst { username, password, password2, type } = user;//从register组件里传递过来this.state作为user，解构出的四个参数\n\tif (!username) {\n\t\treturn errormsg(\"用户名需指定！\")\n\t}else if(password !== password2) { //表单的前台验证：注册时如果两次密码不一致，返回一个errormsg的同步action。\n\t\treturn errormsg(\"2次密码要一致！\");\n\t}\n\t//通过上述判断，说明表单数据合法，返回一个ajax请求的异步action函数\n\treturn async dispatch => {\n\t\t//发送注册的异步ajax请求\n\t\tconst response = await reqRegister({ username, password, type });//调用api/index.js里的reqRegister请求，并传入请求参数\n\t\tconsole.log(response);//这里的response获取到异步请求的结果，结果是一个对象，包含data、status、statusText、headers、config等属性。而data里包含我们需要的code和data数据\n\t\tconst result = response.data;//data数据包括code，data\n\t\tif (result.code === 0) {//注册成功，返回{code:0, data:{\"_id\":\"\", \"username\":\"\", \"type\": \"\"}}对象\n\t\t\tgetMsgList(dispatch, result.data._id); //注册成功, 调用获取消息列表的函数\n\t\t\t//分发授权成功的同步action\n\t\t\tdispatch(authsuccess(result.data));//把action创建函数的结果直接传递给dispatch方法即可发起一次dispatch过程，调用reducer\n\t\t}else{//注册失败,返回{code:1, msg: \"\"}对象\n\t\t\tdispatch(errormsg(result.msg));\n\t\t}\n\t}\n}\n//登陆的异步action.此action返回的是一个函数\nexport const login = (user)=> {\n\tconst { username, password } = user;\n\tif (!username) {\n\t\treturn errormsg(\"用户名必须指定！\")\n\t}else if(!password) { //表单的前台验证：注册时如果两次密码不一致，返回一个errormsg的同步action。\n\t\treturn errormsg(\"密码必须指定\");\n\t}\n\treturn async dispatch => {\n\t\t//发送注册的异步ajax请求\n\t\tconst response = await reqLogin(user);\n\t\tconst result = response.data;//data数据包括code，data\n\t\tif (result.code === 0) {//登陆成功\n\t\t\tgetMsgList(dispatch, result.data._id); //注册成功调用获取消息列表\n\t\t\t//分发授权成功的同步action\n\t\t\tdispatch(authsuccess(result.data));\n\t\t}else{//注册失败\n\t\t\tdispatch(errormsg(result.msg));\n\t\t}\n\t}\n}\n//更新用户状态的异步action。此action返回一个函数\nexport const updateUser = (user) =>{\n\treturn async dispatch =>{\n\t\tconst response = await reqUpdateUser(user);\n\t\tconst result = response.data;\n\t\tif (result.code === 0) {//更新成功 :data,分发一个同步action\n\t\t\tdispatch(receiveUser(result.data));\n\t\t}else{//更新失败： msg\n\t\t\tdispatch(resetUser(result.msg));\n\t\t}\n\t}\n}\n//获取用户的异步action\nexport const getUser = () => {\n\treturn async dispatch => {\n\t\t//执行异步ajax请求\n\t\tconst response = await reqUser(); //reqUser()是一个ajax请求，请求结果包括{code: xx, data:{}}\n\t\tconst result = response.data;\n\t\tif (result.code === 0) {\n\t\t\tgetMsgList(dispatch, result.data._id); //注册成功调用获取消息列表\n\t\t\t//成功获取数据\n\t\t\tdispatch(receiveUser(result.data));\n\t\t}else{\n\t\t\t//获取数据失败\n\t\t\tdispatch(resetUser(result.msg))\n\t\t}\n\t}\n}\n//获取用户列表的异步action\nexport const getUserList = (type)=>{\n\treturn async dispatch =>{\n\t\t//执行异步ajax请求\n\t\tconst response = await reqUserList(type); //api -> index.js -> reqUserList()，请求用户类型\n\t\tconst result = response.data;\n\t\t//得到结果之后分发一个同步action\n\t\tif (result.code === 0) {\n\t\t\tdispatch(receiveUserList(result.data));\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}